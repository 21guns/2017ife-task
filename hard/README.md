1 任务目的
了解事件传播机制
任务描述
这是“动态数据绑定”的第三题。在第二题的基础上，我们再多考虑一个问题："深层次数据变化如何逐层往上传播"。举个例子。

let app2 = new Observer({
    name: {
        firstName: 'shaofeng',
        lastName: 'liang'
    },
    age: 25
});

app2.$watch('name', function (newName) {
    console.log('我的姓名发生了变化，可能是姓氏变了，也可能是名字变了。')
});

app2.data.name.firstName = 'hahaha';
// 输出：我的姓名发生了变化，可能是姓氏变了，也可能是名字变了。
app2.data.name.lastName = 'blablabla';
// 输出：我的姓名发生了变化，可能是姓氏变了，也可能是名字变了。
观察到了吗？firstName 和 lastName 作为 name 的属性，其中任意一个发生变化，都会得出以下结论："name 发生了变化。"这种机制符合”事件传播“机制，方向是从底层往上逐层传播到顶层。
这现象想必你们也见过，比如：“点击某一个DOM元素，相当于也其父元素和其所有祖先元素。”（当然，你可以手动禁止事件传播） 所以，这里的本质是："浏览器内部实现了一个事件传播的机制"，你有信心自己实现一个吗？

任务注意事项
不能使用任何第三方的库
程序执行环境为浏览器
<br><br><br><br><br>
2 任务目的
熟练使用原生 JS对操作 DOM 结构
任务描述
这是“动态数据绑定”的第四题。有了前面的充分准备，相信你能搞定这一题。请实现如下的这样一个 Vue，传入参数是一个 Selector 和一个数据对象，程序需要将 HTML 模板片段渲染成正确的模样。 这就是一次性的静态数据绑定。

let app = new Vue({
  el: '#app',
  data: {
    user: {
      name: 'youngwind',
      age: 25
    }
  }
});
<!-- 页面中原本的 html 模板片段 -->
<div id="app">
    <p>姓名：{{user.name}}</p>
    <p>年龄：{{user.age}}</p>
</div>
<!-- 最终在页面中渲染出来的结果 -->
<div id="app">
    <p>姓名：youngwind</p>
    <p>年龄：25</p>
</div>
PS：此题尚未要求实现动态数据绑定

任务注意事项
不能使用任何第三方的库
程序执行环境为浏览器
<br><br><br><br><br>
3 任务目的
综合应用本系列的所有知识点
任务描述
这是“动态数据绑定”的最后一题了，希望你能坚持到最后。在第四题的基础上，我们考虑如何做到："当数据发生改变时，重新渲染 DOM。" 此目标又可以分为两层难度。

相对简单的目标：数据任意部分发生了变化，都重新渲染 DOM。
相对困难的目标：数据的某一部分发生了变动，只重新渲染对应这部分数据的 DOM。
举个例子。

let app = new Vue({
  el: '#app',
  data: {
    user: {
      name: 'youngwind',
      age: 25
    },
    school: 'bupt',
    major: 'computer'
  }
});
<!-- 页面中原本的 html 模板片段 -->
<div id="app">
    <p>姓名：{{user.name}}</p>
    <p>年龄：{{user.age}}</p>
</div>
相对简单的目标是说：无论是修改数据的哪一部分（包括没有在页面中出现的 school 和 major 这两部分），DOM 都会重新渲染。（即便前后渲染结果一致）
相对困难的目标是说：只有当 user.name 和 user.age 发生改变的时候，DOM 才会重新渲染；而 school 和 major 的变化不会引发重新渲染。

最后，无论你选择哪种难度，能完成本题，就已经很棒了！

如果你想了解更多这个系列的后续，可以访问我的博客。同时也欢迎通过邮件与我联系，进行更多的交流。

任务注意事项
不能使用任何第三方的库
程序执行环境为浏览器
<br><br><br><br><br>
4 网页抓取分析服务系列之五（并发控制）
任务目的
任务的并行控制逻辑设计
socket.io的使用
任务描述
在4的基础上前端增加一个输入选项（页码），表面需要抓取的页数，另外设备输入值由下拉框改为多选框。
单个用户可以选择多个设备的模拟任务，并且每个设备需要抓取多页。
服务器端根据选择的情况，生成任务待执行队列，每个phantomjs任务只执行一次抓取。同时允许nodejs调起最大5个phantomjs的进程。
前后端改为通过web socket通信，使用socket.io库，每完成一个抓取，将结果追加到页面中。同时在页面的最上方显示当前的进度（完成数/总任务数）。
任务注意事项
phantomjs进程的最大5个并发需要考虑多人同时提交和任务积压的情况：即两个用户A、B同时提交了4个任务到服务端，服务端只能执行A的4个、和B的1个，等前面有执行完毕的，B的剩下的再执行。
<br><br><br><br><br>